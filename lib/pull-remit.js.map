{
  "version": 3,
  "file": "pull-remit.js",
  "sourceRoot": "..",
  "sources": [
    "src/pull-remit.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'STEAMPIPES/BASICS'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\n{ jr }                    = CND\nassign                    = Object.assign\n#...........................................................................................................\n{ isa\n  validate\n  type_of }               = require './types'\nmisfit                    = Symbol 'misfit'\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n### Signals are special values that, when sent down the pipeline, may alter behavior: ###\n@signals = Object.freeze\n  last:             Symbol 'last'             # Used to signal last data item\n  end:              Symbol 'end'              # Request stream to terminate\n\n#-----------------------------------------------------------------------------------------------------------\n### Marks are special values that identify types, behavior of pipeline elements etc: ###\n@marks = Object.freeze\n  isa_source:       Symbol 'isa_source'       # Marks a source as such\n  isa_through:      Symbol 'isa_through'      # Marks a through as such\n  isa_sink:         Symbol 'isa_sink'         # Marks a sink as such\n  isa_duct:         Symbol 'isa_duct'         # Marks a duct as such\n  isa_pusher:       Symbol 'isa_pusher'       # Marks a push source as such\n  send_last:        Symbol 'send_last'        # Marks transforms expecting a certain value before EOS\n\n#-----------------------------------------------------------------------------------------------------------\nremit_defaults = Object.freeze\n  first:    misfit\n  last:     misfit\n  between:  misfit\n  after:    misfit\n  before:   misfit\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@_get_remit_settings = ( settings, method ) ->\n  switch remit_arity = arguments.length\n    when 1 then [ method, settings, ] = [ settings, null, ]\n    when 2 then settings = { remit_defaults..., settings..., }\n    else throw new Error \"µ19358 expected 1 or 2 arguments, got #{remit_arity}\"\n  #.........................................................................................................\n  validate.function method\n  throw new Error \"µ20123 method arity #{arity} not implemented\" unless ( arity = method.length ) is 2\n  if settings?\n    validate.function settings.leapfrog if settings.leapfrog?\n    settings._surround = \\\n      ( settings.first    isnt misfit ) or \\\n      ( settings.last     isnt misfit ) or \\\n      ( settings.between  isnt misfit ) or \\\n      ( settings.after    isnt misfit ) or \\\n      ( settings.before   isnt misfit )\n  #.........................................................................................................\n  return { settings, method, }\n\n#-----------------------------------------------------------------------------------------------------------\n@remit  = @$ = ( P... ) =>\n  { settings, method, } = @_get_remit_settings P...\n  has_returned          = false\n  send                  = null\n  #.........................................................................................................\n  tsend = ( d ) =>\n    throw new Error \"µ55663 illegal to call send() after method has returned\" if has_returned\n    send d\n  tsend.end = -> send.end()\n  #.........................................................................................................\n  unless settings?\n    ### fast track without surround features ###\n    return ( d, send_ ) =>\n      send          = send_\n      has_returned  = false\n      method d, tsend\n      has_returned = true\n      return null\n  #.........................................................................................................\n  self                  = null\n  do_leapfrog           = settings.leapfrog\n  data_first            = settings.first\n  data_before           = settings.before\n  data_between          = settings.between\n  data_after            = settings.after\n  data_last             = settings.last\n  send_first            = data_first    isnt misfit\n  send_before           = data_before   isnt misfit\n  send_between          = data_between  isnt misfit\n  send_after            = data_after    isnt misfit\n  send_last             = data_last     isnt misfit\n  on_end                = null\n  is_first              = true\n  ME                    = @\n  #.........................................................................................................\n  ### slow track with surround features ###\n  R = ( d, send_ ) =>\n    # debug 'µ55641', d, d is @signals.last\n    send          = send_\n    has_returned  = false\n    #.......................................................................................................\n    if send_last and d is @signals.last\n      method data_last, tsend\n    #.......................................................................................................\n    else\n      if is_first then ( ( method data_first,   tsend ) if send_first   )\n      else             ( ( method data_between, tsend ) if send_between )\n      ( method data_before, tsend ) if send_before\n      is_first = false\n      #.....................................................................................................\n      # When leapfrogging is being called for, only call method if the jumper returns false:\n      if ( not do_leapfrog ) or ( not settings.leapfrog d ) then  method d, tsend\n      else                                                        send d\n      #.....................................................................................................\n      ( method data_after, tsend ) if send_after\n    has_returned = true\n    return null\n  #.........................................................................................................\n  R[ @marks.send_last ] = @marks.send_last if send_last\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@_classify_transform = ( transform ) ->\n  R = do =>\n    return { type: transform.type,              } if transform[ @marks.isa_duct   ]?\n    return { type: 'source', isa_pusher: true,  } if transform[ @marks.isa_pusher ]?\n    return { type: 'source',                    } if transform[ Symbol.iterator   ]?\n    switch type = type_of transform\n      when 'function'           then return { type: 'through', }\n      when 'generatorfunction'  then return { type: 'source', must_call: true, }\n    return { type: 'sink', on_end: transform.on_end, } if transform[ @marks.isa_sink ]?\n    throw new Error \"µ44521 expected an iterable, a function, a generator function or a sink, got a #{type}\"\n  switch R.type\n    when 'source'   then  transform[ @marks.isa_source  ] ?= @marks.isa_source\n    when 'through'  then  transform[ @marks.isa_through ] ?= @marks.isa_through\n    when 'sink'     then  transform[ @marks.isa_sink    ] ?= @marks.isa_sink\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@_flatten_transforms = ( transforms, R = null ) ->\n  R ?= []\n  for transform in transforms\n    if transform[ @marks.isa_duct ]?\n      ### TAINT necessary to do this recursively? ###\n      R.push t for t in transform.transforms\n    else\n      R.push transform\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@_new_duct = ( transforms ) ->\n  transforms  = @_flatten_transforms transforms\n  R           = { [@marks.isa_duct], transforms, }\n  blurbs      = ( @_classify_transform transform for transform in transforms )\n  return { R..., is_empty: true, } if transforms.length is 0\n  #.........................................................................................................\n  R.first = blurbs[ 0 ]\n  if transforms.length is 1\n    R.is_single   = true\n    R.last        = R.first\n    R.type        = R.first.type\n  else\n    R.last        = blurbs[ transforms.length - 1 ]\n    switch key = \"#{R.first.type}/#{R.last.type}\"\n      when 'source/through'   then R.type = 'source'\n      when 'through/sink'     then R.type = 'sink'\n      when 'through/through'  then R.type = 'through'\n      when 'source/sink'      then R.type = 'circuit'\n      else throw new Error \"µ44521 illegal duct configuration #{rpr key}\"\n    for idx in [ 1 ... blurbs.length - 1 ] by +1\n      unless ( b = blurbs[ idx ] ).type is 'through'\n        throw new Error \"µ44522 illegal duct configuration at transform index #{idx}: #{rpr b}\"\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@_pull = ( transforms... ) ->\n  duct                  = @_new_duct transforms\n  { transforms, }       = duct\n  original_source       = null\n  throw new Error \"µ77764 source as last transform not yet supported\" if duct.last.type  is 'source'\n  throw new Error \"µ77765 sink as first transform not yet supported\"  if duct.first.type is 'sink'\n  #.........................................................................................................\n  if duct.first.type is 'source'\n    original_source = transforms.shift()\n    original_source = original_source() if duct.first.must_call\n  #.........................................................................................................\n  if duct.last.type is 'sink'\n    transforms.pop()\n  #.........................................................................................................\n  return duct unless duct.type is 'circuit'\n  #.........................................................................................................\n  duct.original_source  = original_source\n  duct.mem_source       = mem_source      = []\n  duct.mem_sources      = mem_sources     = [ mem_source, ( [] for _ in [ 0 ... transforms.length ] )..., ]\n  duct.has_ended        = false\n  local_sink            = null\n  local_source          = null\n  last                  = @signals.last\n  #.........................................................................................................\n  send = ( d ) =>\n    return duct.has_ended = true if d is @signals.end\n    local_sink.push d\n  send.end = => duct.has_ended = true\n  #.........................................................................................................\n  exhaust_pipeline = =>\n    loop\n      has_data = false\n      for transform, idx in transforms\n        continue if ( local_source = mem_sources[ idx ] ).length is 0\n        has_data      = true\n        local_sink    = mem_sources[ idx + 1 ]\n        d             = local_source.shift()\n        if d is last\n          transform d, send if transform[ @marks.send_last ]?\n          send last\n        else\n          transform d, send\n      break unless has_data\n    return null\n  #.........................................................................................................\n  duct.send             = send\n  duct.exhaust_pipeline = exhaust_pipeline\n  #.........................................................................................................\n  return duct\n\n#-----------------------------------------------------------------------------------------------------------\n@pull = ( transforms... ) ->\n  duct = @_pull transforms...\n  return duct unless duct.type is 'circuit'\n  return @_push duct if duct.original_source[ @marks.isa_pusher ]?\n  #.........................................................................................................\n  for d from duct.original_source\n    break if duct.has_ended\n    # continue if d is @signals.discard\n    duct.mem_source.push d\n    duct.exhaust_pipeline()\n  #.........................................................................................................\n  duct.mem_source.push @signals.last\n  duct.exhaust_pipeline()\n  duct.last.on_end() if duct.last.on_end?\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@_push = ( duct ) ->\n  ### Make `duct` available from the POV of the push source: ###\n  duct.original_source.duct = duct\n  ### copy buffered data (from before when `pull()` was called) to `original_source`: ###\n  duct.mem_source.splice duct.mem_source.length, 0, duct.original_source.buffer...\n  ### Process any data as may have accumulated at this point: ###\n  duct.exhaust_pipeline()\n  return null\n\n\n"
  ]
}